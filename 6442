#!/usr/bin/env python3

import json
import sys
import requests
import logging
import os
import time

# ---------------------------
# Configuration Section
# ---------------------------

# Static URL to fetch the JSON data
JSON_DATA_URL = "https://api.example.com/hosts"  # Replace with your actual URL

# Static payload for the HTTP request.
# If using GET, set PAYLOAD to None. If using POST, provide the necessary payload.
PAYLOAD = None  # Set to your payload dictionary if using POST, else None

# Static headers for the HTTP request
HTTP_HEADERS = {
    "Authorization": "Bearer YOUR_API_TOKEN",  # Replace with your actual token
    "Content-Type": "application/json"
}

# Proxy settings (optional). Set to None or empty dict {} if not using a proxy.
PROXIES = {}  # Example:
# PROXIES = {
#     "http": "http://username:password@proxy.example.com:8080",
#     "https": "https://username:password@proxy.example.com:8080",
# }

# Cache configuration (optional)
CACHE_FILE = '/tmp/dynamic_inventory_cache.json'
CACHE_TTL = 300  # Cache Time-To-Live in seconds

# Logging configuration
LOG_FILE = '/var/log/ansible/dynamic_inventory.log'
logging.basicConfig(
    filename=LOG_FILE,
    level=logging.INFO,
    format='%(asctime)s %(levelname)s:%(message)s'
)

# ---------------------------
# End of Configuration
# ---------------------------

def fetch_json_data(url, headers=None, payload=None, proxies=None):
    """
    Fetches JSON data from the specified URL using HTTP GET or POST.

    Args:
        url (str): The URL to fetch data from.
        headers (dict): HTTP headers to include in the request.
        payload (dict or None): Payload for POST requests. If None, a GET request is made.
        proxies (dict or None): Proxy settings for the request.

    Returns:
        dict: Parsed JSON response.

    Exits:
        On request failure or JSON decoding error.
    """
    try:
        if payload:
            response = requests.post(url, headers=headers, json=payload, proxies=proxies, timeout=10)
            logging.info(f"Sent POST request to {url} with payload: {payload}")
        else:
            response = requests.get(url, headers=headers, proxies=proxies, timeout=10)
            logging.info(f"Sent GET request to {url}")

        response.raise_for_status()
        logging.info(f"Received response from {url}: {response.status_code}")
        return response.json()
    except requests.exceptions.ProxyError as e:
        logging.error(f"Proxy error while connecting to {url}: {e}")
        print(f"Proxy error: {e}", file=sys.stderr)
        sys.exit(1)
    except requests.exceptions.RequestException as e:
        logging.error(f"HTTP request error while connecting to {url}: {e}")
        print(f"HTTP request error: {e}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        logging.error(f"JSON decoding error: {e}")
        print(f"JSON decoding error: {e}", file=sys.stderr)
        sys.exit(1)

def fetch_json_data_with_cache(url, headers=None, payload=None, proxies=None):
    """
    Fetches JSON data with caching. Uses cached data if it's fresh.

    Args:
        url (str): The URL to fetch data from.
        headers (dict): HTTP headers to include in the request.
        payload (dict or None): Payload for POST requests.
        proxies (dict or None): Proxy settings for the request.

    Returns:
        dict: Parsed JSON response.
    """
    if os.path.exists(CACHE_FILE):
        cache_age = int(time.time()) - int(os.path.getmtime(CACHE_FILE))
        if cache_age < CACHE_TTL:
            try:
                with open(CACHE_FILE, 'r') as f:
                    logging.info("Using cached inventory data")
                    return json.load(f)
            except Exception as e:
                logging.warning(f"Failed to read cache file: {e}")
                # Proceed to fetch fresh data

    # Fetch fresh data
    data = fetch_json_data(url, headers=headers, payload=payload, proxies=proxies)

    # Cache the data
    try:
        with open(CACHE_FILE, 'w') as f:
            json.dump(data, f)
            logging.info("Cached new inventory data")
    except Exception as e:
        logging.warning(f"Failed to write cache file: {e}")

    return data

def generate_inventory(data):
    """
    Generates Ansible inventory structure from the fetched data.

    Args:
        data (dict): Parsed JSON data containing host information.

    Returns:
        dict: Ansible inventory structure matching the expected output.
    """
    inventory = {
        "_meta": {
            "hostvars": {}
        },
        "all": {
            "children": []
        }
    }

    all_group_children = set()
    group_definitions = {}

    source = data.get('source', [])
    if not isinstance(source, list):
        logging.error("Invalid JSON structure: 'source' key missing or not a list")
        print("Invalid JSON structure: 'source' key missing or not a list", file=sys.stderr)
        sys.exit(1)

    for item in source:
        fqdn = item.get('fqdn')
        environment = item.get('environment')
        app_code = item.get('appCodeMain')

        if not fqdn:
            logging.warning("An item in 'source' does not have 'fqdn'")
            print("Warning: An item in 'source' does not have 'fqdn'", file=sys.stderr)
            continue

        # Add host variables
        inventory['_meta']['hostvars'][fqdn] = {}
        if environment:
            inventory['_meta']['hostvars'][fqdn]['environment'] = environment
        if app_code:
            inventory['_meta']['hostvars'][fqdn]['appCodeMain'] = app_code

        # Process environment group
        if environment:
            if environment not in group_definitions:
                group_definitions[environment] = {
                    "hosts": [],
                    "children": []
                }
                all_group_children.add(environment)
            group_definitions[environment]["hosts"].append(fqdn)

            # Process AppCode group
            if app_code:
                appcode_group_name = f"AppCode_{app_code}"
                # Define the AppCode group if not already defined
                if appcode_group_name not in group_definitions:
                    group_definitions[appcode_group_name] = {
                        "hosts": []
                    }
                    all_group_children.add(appcode_group_name)
                # Add host to AppCode group
                group_definitions[appcode_group_name]["hosts"].append(fqdn)

                # Add AppCode group as a child of the environment group
                if appcode_group_name not in group_definitions[environment]["children"]:
                    group_definitions[environment]["children"].append(appcode_group_name)
            else:
                logging.warning(f"Host {fqdn} does not have 'appCodeMain'")
                print(f"Warning: Host {fqdn} does not have 'appCodeMain'", file=sys.stderr)
        else:
            logging.warning(f"Host {fqdn} does not have 'environment'")
            print(f"Warning: Host {fqdn} does not have 'environment'", file=sys.stderr)

    # Add all group definitions to the inventory
    inventory.update(group_definitions)
    # Update 'all' group's children
    inventory['all']['children'] = list(all_group_children)

    return inventory

def main():
    """
    Main function to handle command-line arguments and output the inventory.
    """
    if len(sys.argv) == 2:
        if sys.argv[1] == '--list':
            # Fetch JSON data with caching
            data = fetch_json_data_with_cache(
                JSON_DATA_URL,
                headers=HTTP_HEADERS,
                payload=PAYLOAD,
                proxies=PROXIES
            )

            # Generate inventory
            inventory = generate_inventory(data)

            # Output the inventory in JSON format
            print(json.dumps(inventory, indent=2))
            sys.exit(0)

        elif sys.argv[1].startswith('--host='):
            # Extract host name
            host = sys.argv[1].split('=')[1]
            # Return host-specific variables if available
            inventory = generate_inventory(fetch_json_data_with_cache(
                JSON_DATA_URL,
                headers=HTTP_HEADERS,
                payload=PAYLOAD,
                proxies=PROXIES
            ))
            host_vars = inventory['_meta']['hostvars'].get(host, {})
            print(json.dumps(host_vars))
            sys.exit(0)

    # If no arguments or unrecognized arguments are provided, display help
    print("Usage:")
    print("  dynamic_inventory.py --list")
    print("  dynamic_inventory.py --host=hostname")
    sys.exit(1)

if __name__ == '__main__':
    main()
